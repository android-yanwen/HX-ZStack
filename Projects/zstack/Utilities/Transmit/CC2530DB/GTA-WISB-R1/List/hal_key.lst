###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             15/Aug/2016  19:57:31 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Co #
#                          mponents\hal\target\CC2530EB\hal_key.c             #
#    Command line       =  -f D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£© #
#                          \Projects\zstack\Utilities\Transmit\CC2530DB\..\.. #
#                          \..\Tools\CC2530DB\f8wEndev.cfg (-DCPU32MHZ        #
#                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3         #
#                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f          #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO         #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00001000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1178                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=3             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=2    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=TRUE -DPOLL_RATE=1000         #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 D:\work\ZSTACK-GTAMODBUS-Ö÷ #
#                          ¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Components\hal\target\CC2530E #
#                          B\hal_key.c -D NWK_AUTO_POLL -D MT_TASK -D         #
#                          ZTOOL_P1 -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D        #
#                          ZDNWKMGR_MIN_TRANSMISSIONS=0 -D GTA_DEBUG -D       #
#                          ZIGBEEPRO -D GTA_WISB_R1 -lC                       #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\GTA-WISB #
#                          -R1\List\ -lA D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140 #
#                          707£¨Û³ÎÄ£©\Projects\zstack\Utilities\Transmit\CC2 #
#                          530DB\GTA-WISB-R1\List\ --diag_suppress            #
#                          Pe001,Pa010 -o D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«14 #
#                          0707£¨Û³ÎÄ£©\Projects\zstack\Utilities\Transmit\CC #
#                          2530DB\GTA-WISB-R1\Obj\ -e --no_code_motion        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£© #
#                          \Projects\zstack\Utilities\Transmit\CC2530DB\ -I   #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\Sourc #
#                          e\ -I D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³Î #
#                          Ä£©\Projects\zstack\Utilities\Transmit\CC2530DB\.. #
#                          \..\..\ZMain\TI2530DB\ -I                          #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\hal\include\ -I                  #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\hal\target\CC2530EB\ -I          #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\mac\include\ -I                  #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\mac\high_level\ -I               #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\mac\low_level\srf04\ -I          #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\mac\low_level\srf04\single_chip\ #
#                           -I D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£ #
#                          ©\Projects\zstack\Utilities\Transmit\CC2530DB\..\. #
#                          .\..\..\..\Components\mt\ -I                       #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\osal\include\ -I                 #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\services\saddr\ -I               #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\services\sdata\ -I               #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\af\ -I                     #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\nwk\ -I                    #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\sapi\ -I                   #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\sec\ -I                    #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\sys\ -I                    #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\stack\zdo\ -I                    #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\zmac\ -I                         #
#                          D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\zmac\f8w\ -Ohz                   #
#                          --require_prototypes                               #
#    List file          =  D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\GTA-WISB #
#                          -R1\List\hal_key.lst                               #
#    Object file        =  D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\GTA-WISB #
#                          -R1\Obj\hal_key.r51                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\ZSTACK-GTAMODBUS-Ö÷¶¯ÉÏ´«140707£¨Û³ÎÄ£©\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_board.h"
     87          #include "hal_drivers.h"
     88          #include "hal_adc.h"
     89          #include "hal_key.h"
     90          #include "osal.h"
     91          
     92          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     93          
     94          /**************************************************************************************************
     95           *                                              MACROS
     96           **************************************************************************************************/
     97          
     98          /**************************************************************************************************
     99           *                                            CONSTANTS
    100           **************************************************************************************************/
    101          #define HAL_KEY_RISING_EDGE   0
    102          #define HAL_KEY_FALLING_EDGE  1
    103          
    104          #define HAL_KEY_DEBOUNCE_VALUE  25
    105          #define HAL_KEY_POLLING_VALUE   100
    106                   
    107          /* CPU port interrupt */
    108          #define HAL_KEY_CPU_PORT_0_IF P0IF
    109          #define HAL_KEY_CPU_PORT_2_IF P2IF
    110          
    111          /* SW_6 is at P0.1 */
    112          #define HAL_KEY_SW_6_PORT   P0
    113          #define HAL_KEY_SW_6_BIT    BV(1)
    114          #define HAL_KEY_SW_6_SEL    P0SEL
    115          #define HAL_KEY_SW_6_DIR    P0DIR
    116          
    117          /* edge interrupt */
    118          #define HAL_KEY_SW_6_EDGEBIT  BV(0)
    119          #define HAL_KEY_SW_6_EDGE     HAL_KEY_FALLING_EDGE
    120          
    121          
    122          /* SW_6 interrupts */
    123          #define HAL_KEY_SW_6_IEN      IEN1  /* CPU interrupt mask register */
    124          #define HAL_KEY_SW_6_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    125          #define HAL_KEY_SW_6_ICTL     P0IEN /* Port Interrupt Control register */
    126          #define HAL_KEY_SW_6_ICTLBIT  BV(1) /* P0IEN - P0.1 enable/disable bit */
    127          #define HAL_KEY_SW_6_PXIFG    P0IFG /* Interrupt flag at source */
    128          
    129          /* Joy stick move at P2.0 */
    130          //#define HAL_KEY_JOY_MOVE_PORT   P2
    131          #define HAL_KEY_JOY_MOVE_PORT   P0//microdjg
    132          //#define HAL_KEY_JOY_MOVE_BIT    BV(0)
    133          #define HAL_KEY_JOY_MOVE_BIT    BV(7)//microdjg
    134          //#define HAL_KEY_JOY_MOVE_SEL    P2SEL
    135          #define HAL_KEY_JOY_MOVE_SEL    P0SEL
    136          //#define HAL_KEY_JOY_MOVE_DIR    P2DIR
    137          #define HAL_KEY_JOY_MOVE_DIR    P0DIR
    138          /* edge interrupt */
    139          #define HAL_KEY_JOY_MOVE_EDGEBIT  BV(7)
    140          #define HAL_KEY_JOY_MOVE_EDGE     HAL_KEY_FALLING_EDGE
    141          
    142          /* edge interrupt */
    143          //#define HAL_KEY_JOY_MOVE_EDGEBIT  BV(3)
    144          //#define HAL_KEY_JOY_MOVE_EDGE     HAL_KEY_FALLING_EDGE
    145          
    146          /* Joy move interrupts */
    147          
    148          //#define HAL_KEY_JOY_MOVE_IEN      IEN2  /* CPU interrupt mask register */
    149          //#define HAL_KEY_JOY_MOVE_IENBIT   BV(1) /* Mask bit for all of Port_2 */
    150          //#define HAL_KEY_JOY_MOVE_ICTL     P2IEN /* Port Interrupt Control register */
    151          //#define HAL_KEY_JOY_MOVE_ICTLBIT  BV(0) /* P2IENL - P2.0<->P2.3 enable/disable bit */
    152          //#define HAL_KEY_JOY_MOVE_PXIFG    P2IFG /* Interrupt flag at source */
    153          
    154          /* Joy move interrupts  GTA */
    155          #define HAL_KEY_JOY_MOVE_IEN      IEN1  /* CPU interrupt mask register */
    156          #define HAL_KEY_JOY_MOVE_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    157          #define HAL_KEY_JOY_MOVE_ICTL     P0IEN /* Port Interrupt Control register */
    158          #define HAL_KEY_JOY_MOVE_ICTLBIT  BV(7) /* P0IENL - enable/disable bit */
    159          #define HAL_KEY_JOY_MOVE_PXIFG    P0IFG /* Interrupt flag at source */
    160          
    161          #define HAL_KEY_JOY_MOVE_PICTL    PICTL//microdjg
    162          
    163          
    164          
    165          #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    166          
    167          
    168          /**************************************************************************************************
    169           *                                            TYPEDEFS
    170           **************************************************************************************************/
    171          
    172          
    173          /**************************************************************************************************
    174           *                                        GLOBAL VARIABLES
    175           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    177          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    178          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    180          
    181          /**************************************************************************************************
    182           *                                        FUNCTIONS - Local
    183           **************************************************************************************************/
    184          void halProcessKeyInterrupt(void);
    185          uint8 halGetJoyKeyInput(void);
    186          
    187          
    188          
    189          /**************************************************************************************************
    190           *                                        FUNCTIONS - API
    191           **************************************************************************************************/
    192          
    193          
    194          /**************************************************************************************************
    195           * @fn      HalKeyInit
    196           *
    197           * @brief   Initilize Key Service
    198           *
    199           * @param   none
    200           *
    201           * @return  None
    202           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    203          void HalKeyInit( void )
   \                     HalKeyInit:
    204          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    205            /* Initialize previous key to 0 */
    206            halKeySavedKeys = 0;
   \   000004   90....       MOV     DPTR,#halKeySavedKeys
   \   000007   E4           CLR     A
   \   000008   F0           MOVX    @DPTR,A
    207          
    208            //HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
    209            //HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
    210          
    211            HAL_KEY_JOY_MOVE_SEL &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin function to GPIO */
   \   000009   53F37F       ANL     0xf3,#0x7f
    212            //HAL_KEY_JOY_MOVE_DIR &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin direction to Input */
    213          
    214            HAL_KEY_JOY_MOVE_DIR &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin direction to Input */
   \   00000C   53FD7F       ANL     0xfd,#0x7f
    215            HAL_KEY_JOY_MOVE_PICTL |=0x01;//P0 falling interrupt
   \   00000F   438C01       ORL     0x8c,#0x1
    216            
    217            /* Initialize callback function */
    218            pHalKeyProcessFunction  = NULL;
   \   000012   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   F0           MOVX    @DPTR,A
    219          
    220            /* Start with key is not configured */
    221            HalKeyConfigured = FALSE;
   \   000018   90....       MOV     DPTR,#HalKeyConfigured
   \   00001B   F0           MOVX    @DPTR,A
    222          }
   \   00001C   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   00001F                REQUIRE P0SEL
   \   00001F                REQUIRE P0DIR
   \   00001F                REQUIRE PICTL

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    223          
    224          
    225          /**************************************************************************************************
    226           * @fn      HalKeyConfig
    227           *
    228           * @brief   Configure the Key serivce
    229           *
    230           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    231           *          cback - pointer to the CallBack function
    232           *
    233           * @return  None
    234           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    235          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    236          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    237            /* Enable/Disable Interrupt or */
    238            Hal_KeyIntEnable = interruptEnable;
   \   000006   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000009   F0           MOVX    @DPTR,A
    239          
    240            /* Register the callback fucntion */
    241            pHalKeyProcessFunction = cback;
   \   00000A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00000D   EA           MOV     A,R2
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   EB           MOV     A,R3
   \   000011   F0           MOVX    @DPTR,A
    242          
    243            /* Determine if interrupt is enable or not */
    244            if (Hal_KeyIntEnable)
   \   000012   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000015   E0           MOVX    A,@DPTR
   \   000016   6024         JZ      ??HalKeyConfig_0
    245            {
    246              /* Rising/Falling edge configuratinn */
    247          
    248              HAL_KEY_JOY_MOVE_ICTL &= ~(HAL_KEY_JOY_MOVE_EDGEBIT);    /* Clear the edge bit */
   \   000018   53AB7F       ANL     0xab,#0x7f
    249              /* For falling edge, the bit must be set. */
    250            #if (HAL_KEY_JOY_MOVE_EDGE == HAL_KEY_FALLING_EDGE)
    251              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_EDGEBIT;
   \   00001B   43AB80       ORL     0xab,#0x80
    252            #endif
    253          
    254          
    255              /* Interrupt configuration:
    256               * - Enable interrupt generation at the port
    257               * - Enable CPU interrupt
    258               * - Clear any pending interrupt
    259               */
    260              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_ICTLBIT;
   \   00001E   43AB80       ORL     0xab,#0x80
    261              HAL_KEY_JOY_MOVE_IEN |= HAL_KEY_JOY_MOVE_IENBIT;
   \   000021   D2BD         SETB    0xb8.5
    262              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT);
                                              ^
Warning[Pe069]: integer conversion resulted in truncation
   \   000023   75897F       MOV     0x89,#0x7f
    263          
    264          
    265              /* Do this only after the hal_key is configured - to work with sleep stuff */
    266              if (HalKeyConfigured == TRUE)
   \   000026   90....       MOV     DPTR,#HalKeyConfigured
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6401         XRL     A,#0x1
   \   00002C   701E         JNZ     ??HalKeyConfig_1
    267              {
    268                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   00002E                ; Setup parameters for call to function osal_stop_timerEx
   \   00002E   7A01         MOV     R2,#0x1
   \   000030   7B00         MOV     R3,#0x0
   \   000032   90....       MOV     DPTR,#Hal_TaskID
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F9           MOV     R1,A
   \   000037   12....       LCALL   ??osal_stop_timerEx?relay
   \   00003A   8010         SJMP    ??HalKeyConfig_1
    269              }
    270            }
    271            else    /* Interrupts NOT enabled */
    272            {
    273              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
   \                     ??HalKeyConfig_0:
   \   00003C                ; Setup parameters for call to function osal_start_timerEx
   \   00003C   7C64         MOV     R4,#0x64
   \   00003E   7D00         MOV     R5,#0x0
   \   000040   7A01         MOV     R2,#0x1
   \   000042   7B00         MOV     R3,#0x0
   \   000044   90....       MOV     DPTR,#Hal_TaskID
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F9           MOV     R1,A
   \   000049   12....       LCALL   ??osal_start_timerEx?relay
    274            }
    275          
    276            /* Key now is configured */
    277            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   00004C   90....       MOV     DPTR,#HalKeyConfigured
   \   00004F   7401         MOV     A,#0x1
   \   000051   F0           MOVX    @DPTR,A
    278          }
   \   000052   FF           MOV     R7,A
   \   000053   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000056                REQUIRE P0IEN
   \   000056                REQUIRE _A_IEN1
   \   000056                REQUIRE P0IFG
    279          
    280          /**************************************************************************************************
    281           * @fn      HalKeyRead
    282           *
    283           * @brief   Read the current value of a key
    284           *
    285           * @param   None
    286           *
    287           * @return  keys - current keys status
    288           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    289          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    290          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    291            uint8 keys = 0;
   \   000004   7900         MOV     R1,#0x0
    292          
    293            if (HAL_PUSH_BUTTON1())
   \   000006   A2A1         MOV     C,0xa0.1
   \   000008   5002         JNC     ??HalKeyRead_0
    294            {
    295              keys |= HAL_KEY_SW_6;
   \   00000A   7920         MOV     R1,#0x20
    296            }
    297          
    298            if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active low */
   \                     ??HalKeyRead_0:
   \   00000C   A287         MOV     C,0x80.7
   \   00000E   5003         JNC     ??HalKeyRead_1
    299            {
    300              //keys |= halGetJoyKeyInput();
    301              //keys |= halGetJoyKeyInput();//MICRODJG
    302              keys = halGetJoyKeyInput();
   \   000010                ; Setup parameters for call to function halGetJoyKeyInput
   \   000010   12....       LCALL   ??halGetJoyKeyInput?relay
    303            }
    304          
    305            return keys;
   \                     ??HalKeyRead_1:
   \   000013   80..         SJMP    ?Subroutine0
   \   000015                REQUIRE _A_P2
   \   000015                REQUIRE _A_P0
    306          }
    307          
    308          
    309          /**************************************************************************************************
    310           * @fn      HalKeyPoll
    311           *
    312           * @brief   Called by hal_driver to poll the keys
    313           *
    314           * @param   None
    315           *
    316           * @return  None
    317           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    318          void HalKeyPoll (void)
   \                     HalKeyPoll:
    319          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    320            uint8 keys = 0;
    321          
    322            //if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active HIGH */
    323            //{
    324            //  keys = halGetJoyKeyInput();
    325            //}
    326          
    327            /* If interrupts are not enabled, previous key status and current key status
    328             * are compared to find out if a key has changed status.
    329             */
    330            if (!Hal_KeyIntEnable)
   \   000004   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7010         JNZ     ??HalKeyPoll_0
    331            {
    332              keys = halGetJoyKeyInput();//ADCÖµ
   \   00000A                ; Setup parameters for call to function halGetJoyKeyInput
   \   00000A   12....       LCALL   ??halGetJoyKeyInput?relay
    333              if (keys == halKeySavedKeys)
   \   00000D   90....       MOV     DPTR,#halKeySavedKeys
   \   000010   E0           MOVX    A,@DPTR
   \   000011   69           XRL     A,R1
   \   000012   6033         JZ      ??HalKeyPoll_1
    334              {
    335                /* Exit - since no keys have changed */
    336                return;
    337              }
    338              /* Store the current keys for comparation next time */
    339              halKeySavedKeys = keys;
   \   000014   E9           MOV     A,R1
   \   000015   F0           MOVX    @DPTR,A
    340            }
    341            else
    342            {
    343              /* Key interrupt handled here */
    344              if ((HAL_KEY_JOY_MOVE_PORT | (~HAL_KEY_JOY_MOVE_BIT))==(~HAL_KEY_JOY_MOVE_BIT))  /* Key is active LOW *///microdjg
    345              {
    346                keys=HAL_KEY_INT_1;
    347              }
    348            }
    349          
    350          //  if (HAL_PUSH_BUTTON1())
    351          //  {
    352          //    keys |= HAL_KEY_SW_6;
    353          //  }
    354          
    355            /* Invoke Callback if new keys were depressed */
    356            if (keys && (pHalKeyProcessFunction))
   \   000016   7013         JNZ     ??HalKeyPoll_2
   \   000018   802D         SJMP    ??HalKeyPoll_1
   \                     ??HalKeyPoll_0:
   \   00001A   E580         MOV     A,0x80
   \   00001C   447F         ORL     A,#0x7f
   \   00001E   F8           MOV     R0,A
   \   00001F   747F         MOV     A,#0x7f
   \   000021   68           XRL     A,R0
   \   000022   7003         JNZ     ??HalKeyPoll_3
   \   000024   74FF         MOV     A,#-0x1
   \   000026   F4           CPL     A
   \                     ??HalKeyPoll_3:
   \   000027   701E         JNZ     ??HalKeyPoll_1
   \   000029   79E1         MOV     R1,#-0x1f
   \                     ??HalKeyPoll_2:
   \   00002B   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   FA           MOV     R2,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FB           MOV     R3,A
   \   000033   EA           MOV     A,R2
   \   000034   4B           ORL     A,R3
   \   000035   6010         JZ      ??HalKeyPoll_1
    357            {
    358              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   000037                ; Setup parameters for indirect call
   \   000037   7A00         MOV     R2,#0x0
   \   000039   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F583         MOV     DPH,A
   \   000042   8882         MOV     DPL,R0
   \   000044   12....       LCALL   ?CALL_IND
    359            }
   \                     ??HalKeyPoll_1:
   \   000047                REQUIRE ?Subroutine0
   \   000047                REQUIRE _A_P0
   \   000047                ; // Fall through to label ?Subroutine0
    360          }
    361          
    362          /**************************************************************************************************
    363           * @fn      halGetJoyKeyInput
    364           *
    365           * @brief   Map the ADC value to its corresponding key.
    366           *
    367           * @param   None
    368           *
    369           * @return  keys - current joy key status
    370           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    371          uint8 halGetJoyKeyInput(void)
   \                     halGetJoyKeyInput:
    372          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    373            /* The joystick control is encoded as an analog voltage.
    374             * Read the JOY_LEVEL analog value and map it to joy movement.
    375             */
    376            uint8 adc;
    377            uint8 ksave0 = 0;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    378            uint8 ksave1;
    379          
    380            /* Keep on reading the ADC until two consecutive key decisions are the same. */
    381            do
    382            {
    383              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??halGetJoyKeyInput_0:
   \   000008   AE..         MOV     R6,?V0 + 0
    384          
    385              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   00000A                ; Setup parameters for call to function HalAdcRead
   \   00000A   7A01         MOV     R2,#0x1
   \   00000C   7906         MOV     R1,#0x6
   \   00000E   12....       LCALL   ??HalAdcRead?relay
   \   000011   EA           MOV     A,R2
   \   000012   F8           MOV     R0,A
    386          
    387              if ((adc >= 2) && (adc <= 38))
   \   000013   74FE         MOV     A,#-0x2
   \   000015   28           ADD     A,R0
   \   000016   C3           CLR     C
   \   000017   9425         SUBB    A,#0x25
   \   000019   5005         JNC     ??halGetJoyKeyInput_1
    388              {
    389                 //ksave0 |= HAL_KEY_UP;
    390                ksave0 = HAL_KEY_UP;
   \   00001B   75..A0       MOV     ?V0 + 0,#-0x60
   \   00001E   8032         SJMP    ??halGetJoyKeyInput_2
    391              }
    392              else if ((adc >= 74) && (adc <= 88))
   \                     ??halGetJoyKeyInput_1:
   \   000020   74B6         MOV     A,#-0x4a
   \   000022   28           ADD     A,R0
   \   000023   C3           CLR     C
   \   000024   940F         SUBB    A,#0xf
   \   000026   5005         JNC     ??halGetJoyKeyInput_3
    393              {
    394                //ksave0 |= HAL_KEY_RIGHT;
    395                ksave0 = HAL_KEY_RIGHT;
   \   000028   75..A1       MOV     ?V0 + 0,#-0x5f
   \   00002B   8025         SJMP    ??halGetJoyKeyInput_2
    396              }
    397              else if ((adc >= 60) && (adc <= 73))
   \                     ??halGetJoyKeyInput_3:
   \   00002D   74C4         MOV     A,#-0x3c
   \   00002F   28           ADD     A,R0
   \   000030   C3           CLR     C
   \   000031   940E         SUBB    A,#0xe
   \   000033   5005         JNC     ??halGetJoyKeyInput_4
    398              {
    399                //ksave0 |= HAL_KEY_LEFT;
    400                ksave0 = HAL_KEY_LEFT;
   \   000035   75..A3       MOV     ?V0 + 0,#-0x5d
   \   000038   8018         SJMP    ??halGetJoyKeyInput_2
    401              }
    402              else if ((adc >= 39) && (adc <= 59))
   \                     ??halGetJoyKeyInput_4:
   \   00003A   74D9         MOV     A,#-0x27
   \   00003C   28           ADD     A,R0
   \   00003D   C3           CLR     C
   \   00003E   9415         SUBB    A,#0x15
   \   000040   5005         JNC     ??halGetJoyKeyInput_5
    403              {
    404                //ksave0 |= HAL_KEY_DOWN;
    405                ksave0 = HAL_KEY_DOWN;
   \   000042   75..A4       MOV     ?V0 + 0,#-0x5c
   \   000045   800B         SJMP    ??halGetJoyKeyInput_2
    406              }
    407              else if ((adc >= 89) && (adc <= 100))
   \                     ??halGetJoyKeyInput_5:
   \   000047   74A7         MOV     A,#-0x59
   \   000049   28           ADD     A,R0
   \   00004A   C3           CLR     C
   \   00004B   940C         SUBB    A,#0xc
   \   00004D   5003         JNC     ??halGetJoyKeyInput_2
    408              {
    409                //ksave0 |= HAL_KEY_CENTER;
    410                ksave0 |= HAL_KEY_CENTER;
   \   00004F   43..A2       ORL     ?V0 + 0,#0xa2
    411              }
    412            } while (ksave0 != ksave1);
   \                     ??halGetJoyKeyInput_2:
   \   000052   EE           MOV     A,R6
   \   000053   65..         XRL     A,?V0 + 0
   \   000055   70B1         JNZ     ??halGetJoyKeyInput_0
    413          
    414            return ksave0;
   \   000057   A9..         MOV     R1,?V0 + 0
   \   000059   7F01         MOV     R7,#0x1
   \   00005B   02....       LJMP    ?BANKED_LEAVE_XDATA
    415          }
    416          
    417          
    418          
    419          
    420          
    421          /**************************************************************************************************
    422           * @fn      halProcessKeyInterrupt
    423           *
    424           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    425           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    426           *
    427           * @param
    428           *
    429           * @return
    430           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    431          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    432          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    433            bool valid=FALSE;
    434          
    435            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)  /* Interrupt Flag has been set */
   \   000004   E589         MOV     A,0x89
   \   000006   A2E7         MOV     C,0xE0 /* A   */.7
   \   000008   5013         JNC     ??halProcessKeyInterrupt_0
    436            {
    437              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT); /* Clear Interrupt Flag */
                                              ^
Warning[Pe069]: integer conversion resulted in truncation
   \   00000A   75897F       MOV     0x89,#0x7f
    438              valid = TRUE;
    439            }
    440          
    441            if (valid)
    442            {
    443              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \   00000D                ; Setup parameters for call to function osal_start_timerEx
   \   00000D   7C19         MOV     R4,#0x19
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7A01         MOV     R2,#0x1
   \   000013   7B00         MOV     R3,#0x0
   \   000015   90....       MOV     DPTR,#Hal_TaskID
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F9           MOV     R1,A
   \   00001A   12....       LCALL   ??osal_start_timerEx?relay
    444            }
    445          }
   \                     ??halProcessKeyInterrupt_0:
   \   00001D   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000020                REQUIRE P0IFG
    446          
    447          /**************************************************************************************************
    448           * @fn      HalKeyEnterSleep
    449           *
    450           * @brief  - Get called to enter sleep mode
    451           *
    452           * @param
    453           *
    454           * @return
    455           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    456          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    457          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    458          }
   \   000000   02....       LJMP    ?BRET
    459          
    460          /**************************************************************************************************
    461           * @fn      HalKeyExitSleep
    462           *
    463           * @brief   - Get called when sleep is over
    464           *
    465           * @param
    466           *
    467           * @return  - return saved keys
    468           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    469          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    470          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    471            /* Wake up and read keys */
    472            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   ??HalKeyRead?relay
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
    473          }
    474          
    475          /***************************************************************************************************
    476           *                                    INTERRUPT SERVICE ROUTINE
    477           ***************************************************************************************************/
    478          
    479          /**************************************************************************************************
    480           * @fn      halKeyPort0Isr
    481           *
    482           * @brief   Port0 ISR
    483           *
    484           * @param
    485           *
    486           * @return
    487           **************************************************************************************************/
    488          /*
    489          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
    490          {
    491            HAL_ENTER_ISR();
    492          
    493            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
    494            {
    495              halProcessKeyInterrupt();
    496            }
    497          
    498            HAL_KEY_SW_6_PXIFG = 0;
    499            HAL_KEY_CPU_PORT_0_IF = 0;
    500            
    501            CLEAR_SLEEP_MODE();
    502            HAL_EXIT_ISR();
    503          }
    504          */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    505          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    506          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    507            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)//ÖÐ¶Ï±ê¼Ç
   \   000007   E589         MOV     A,0x89
   \   000009   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000B   5003         JNC     ??halKeyPort0Isr_0
    508            {
    509              halProcessKeyInterrupt();
   \   00000D                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00000D   12....       LCALL   ??halProcessKeyInterrupt?relay
    510            }
    511            /*
    512              Clear the CPU interrupt flag for Port_2
    513              PxIFG has to be cleared before PxIF
    514              Notes: P2_1 and P2_2 are debug lines.
    515            */
    516            HAL_KEY_JOY_MOVE_PXIFG = 0;
   \                     ??halKeyPort0Isr_0:
   \   000010   758900       MOV     0x89,#0x0
    517            HAL_KEY_CPU_PORT_2_IF = 0;
   \   000013   C2E8         CLR     0xe8.0
    518          }
   \   000015   7F01         MOV     R7,#0x1
   \   000017   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   00001A                REQUIRE P0IFG
   \   00001A                REQUIRE _A_IRCON2

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halGetJoyKeyInput?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halGetJoyKeyInput

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    519          
    520          
    521          #else
    522          
    523          
    524          void HalKeyInit(void){}
    525          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    526          uint8 HalKeyRead(void){ return 0;}
    527          void HalKeyPoll(void){}
    528          
    529          #endif /* HAL_KEY */
    530          
    531          
    532          
    533          
    534          
    535          /**************************************************************************************************
    536          **************************************************************************************************/
    537          
    538          
    539          

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0      9  HalKeyConfig
                          0 0  9 -> osal_start_timerEx
                          0 0  9 -> osal_stop_timerEx
       0      0      0  HalKeyEnterSleep
       2      0      0  HalKeyExitSleep
                          2 0  0 -> HalKeyRead
       2      0      0  HalKeyInit
       2      0      0  HalKeyPoll
                          2 0  0 -> halGetJoyKeyInput
       2      0      0  HalKeyRead
                          2 0  0 -> halGetJoyKeyInput
       0      0      9  halGetJoyKeyInput
                          0 0  9 -> HalAdcRead
       0      0     14  halKeyPort0Isr
                          0 0 14 -> halProcessKeyInterrupt
       2      0     14  halProcessKeyInterrupt
                          2 0  0 -> osal_start_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??HalKeyConfig?relay
       6  ??HalKeyEnterSleep?relay
       6  ??HalKeyExitSleep?relay
       6  ??HalKeyInit?relay
       6  ??HalKeyPoll?relay
       6  ??HalKeyRead?relay
       6  ??halGetJoyKeyInput?relay
       3  ??halKeyPort0Isr??INTVEC 107
       6  ??halProcessKeyInterrupt?relay
       7  ?Subroutine0
      86  HalKeyConfig
       1  HalKeyConfigured
       3  HalKeyEnterSleep
      10  HalKeyExitSleep
      31  HalKeyInit
      71  HalKeyPoll
      21  HalKeyRead
       1  Hal_KeyIntEnable
       1  P0DIR
       1  P0IEN
       1  P0IFG
       1  P0SEL
       1  PICTL
       1  _A_IEN1
       1  _A_IRCON2
       1  _A_P0
       1  _A_P2
      94  halGetJoyKeyInput
      26  halKeyPort0Isr
       1  halKeySavedKeys
      32  halProcessKeyInterrupt
       2  pHalKeyProcessFunction

 
 355 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
   3 bytes in segment INTVEC
  26 bytes in segment NEAR_CODE
   9 bytes in segment SFR_AN
   5 bytes in segment XDATA_Z
 
 429 bytes of CODE  memory (+ 3 bytes shared)
   0 bytes of DATA  memory (+ 9 bytes shared)
   5 bytes of XDATA memory

Errors: none
Warnings: 2
